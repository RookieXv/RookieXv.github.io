[{"content":"在 windows 下，大家可以使用Chocolatey来快速下载搭建一个开发环境。\nChocolatey 的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用 Nuget ）\n另外需要说明的是，Chocolatey只是把官方下载路径封装到了Chocolatey中，所以下载源都是其官方路径，所以下载的一定是合法的，\n但是如果原软件是需要 Licence 注册的话，那么Chocolatey下载安装好的软件还是需要你去购买注册。不过Chocolatey一般还是会选用免费 Licence 可用的软件。\n启动 Windows PowerShell 单击开始菜单按钮，键入 PowerShell，右键单击Windows PowerShell，然后单击「以管理员身份运行」。\n安装 Chocolatey 复制以下命令文本。\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)); choco feature enable -n allowGlobalConfirmation   将复制的文本粘贴到 PowerShell 中，然后按 Enter 键。等待几秒钟以完成命令。\n","description":"","id":0,"section":"posts","tags":["Chocolatey"],"title":"安装Chocolatey","uri":"http://RookieXv.github.io/posts/2020/06/%E5%AE%89%E8%A3%85chocolatey/"},{"content":"1. List  Arraylist： Object数组、快速随机访问、不安全 Vector： Object数组、安全（synchronized） LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)、不安全  2. Set  HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的 TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)  3. Map  HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》 Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 TreeMap： 红黑树（自平衡的排序二叉树）  如何选用集合? 主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。\n","description":"","id":1,"section":"posts","tags":["Collection"],"title":"集合框架底层数据结构总结","uri":"http://RookieXv.github.io/posts/2020/06/%E9%9B%86%E5%90%88/"},{"content":" 在 Java中，我们要获取一个时间段的天数，我们可以使用下面几种方式：\n Period @since 1.8 Duration @since 1.8 ChronoUnit @since 1.8   一. 参数声明 1 2  LocalDate start = LocalDate.of(2020, 1, 1); LocalDate end = LocalDate.of(2020, 5, 1);   二.Period类 主要通过Period类方法getYears()，getMonths() 和 getDays()来计算.\n示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * @Author liuwenxu.com (2020-04-26) * * @param start * @param end * @return void **/ private static void testPeriod(LocalDate start, LocalDate end) { log.info(\u0026#34;startPeriod : {}\u0026#34;, start); log.info(\u0026#34;endPeriod : {}\u0026#34;, end); Period period = Period.between(start, end); log.info(\u0026#34;[{}~{})之间共有：{}年,{}月,{}日\u0026#34;, start, end, period.getYears(), +period.getMonths(), +period.getDays()); }   结果:\n1 2 3  - startPeriod : 2020-01-01 - endPeriod : 2020-05-01 - [2020-01-01~2020-05-01)之间共有：0年,4月,0日   三.Duration类 提供了使用基于时间的值测量时间量的方法:\n天数：toDays(); 小时：toHours();\n分钟：toMinutes();\n秒数：toMillis();\n纳秒：toNanos();\n示例: 转换日期时提前一天\n/**\r* @Author liuwenxu.com (2020-04-26)\r*\r* @param start\r* @param end\r* @return void\r**/\rprivate static void testDuration(LocalDate start, LocalDate end) {\rInstant startInstant = start.atStartOfDay(ZoneId.systemDefault()).toInstant();\rInstant endInstant = end.atStartOfDay(ZoneId.systemDefault()).toInstant();\rlog.info(\u0026quot;startInstant : {}\u0026quot;, startInstant);\rlog.info(\u0026quot;endInstant : {}\u0026quot;, endInstant);\rDuration between = Duration.between(startInstant, endInstant);\rlog.info(\u0026quot;[{}~{})之间共有：{}天\u0026quot;, start, end, between.toDays());\r}\r结果:\n1 2 3  - startInstant : 2019-12-31T16:00:00Z - endInstant : 2020-04-30T16:00:00Z - [2020-01-01~2020-05-01)之间共有：121天   四.ChronoUnit类 ChronoUnit类使用between()方法求在单个时间单位内测量一段时间，例如天数、小时、周或秒等。\n示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * @Author liuwenxu.com (2020-04-26) * * @param start * @param end * @return void **/ private static void testChronoUnit(LocalDate start, LocalDate end) { log.info(\u0026#34;startChronoUnit : {}\u0026#34;, start); log.info(\u0026#34;endChronoUnit : {}\u0026#34;, end); long daysDiff = ChronoUnit.DAYS.between(start, end); log.info(\u0026#34;[{}~{})之间共有：{}天\u0026#34;, start, end, daysDiff); }   结果:\n1 2 3  - startInstant : 2020-01-01 - endInstant : 2020-05-01 - [2020-01-01~2020-05-01)之间共有：121天   ","description":"","id":2,"section":"posts","tags":["Java8","时间类"],"title":"Java8中计算日期时间差","uri":"http://RookieXv.github.io/posts/2020/04/java8%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%AE/"},{"content":" Java中各种时间类型相互转换\n 参数声明： 1 2 3 4 5 6 7  final Date date = new Date(); final Timestamp timestamp = new Timestamp(date.getTime()); final Calendar calendar = Calendar.getInstance(); final Instant instant = Instant.now(); final LocalDateTime localDateTime = LocalDateTime.now(); final ZonedDateTime zonedDateTime = ZonedDateTime.now(); final LocalDate localDate = LocalDate.now();   转Instant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //Date转Instant  Instant dateInstant = date.toInstant(); //Timestamp转Instant  Instant timestampInstant = timestamp.toInstant(); //Calendar转Instant  Instant calendarInstant = calendar.toInstant(); //LocalDateTime转Instant  Instant localDateTimeInstant = localDateTime.atZone(ZoneId.systemDefault()).toInstant(); //ZonedDateTime转Instant  Instant zonedDateTimeInstant = zonedDateTime.toInstant(); //LocalDate转Instant  Instant localDateInstant = localDate.atStartOfDay(ZoneId.systemDefault()).toInstant();   转LocalDateTime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //Date转LocalDateTime  LocalDateTime dateLocalDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()); //Timestamp转LocalDateTime  LocalDateTime timestampLocalDateTime = timestamp.toLocalDateTime(); //Calendar转LocalDateTime  LocalDateTime calendarLocalDateTime = LocalDateTime.ofInstant(calendar.toInstant(), ZoneOffset.systemDefault()); //Instant转LocalDateTime  LocalDateTime instantLocalDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()); //ZonedDateTime转LocalDateTime  LocalDateTime zonedDateTimeLocalDateTime = zonedDateTime.toLocalDateTime(); //LocalDate转LocalDateTime  LocalDateTime localDateLocalDateTime = localDate.atStartOfDay();   转ZonedDateTime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //Date转ZonedDateTime  ZonedDateTime dateZonedDateTime = ZonedDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()); //Timestamp转ZonedDateTime  ZonedDateTime timestampZonedDateTime = ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneId.systemDefault()); //Calendar转ZonedDateTime  ZonedDateTime calendarZonedDateTime = ZonedDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault()); //Instant转ZonedDateTime  ZonedDateTime instantZonedDateTime = instant.atZone(ZoneId.systemDefault()); //LocalDateTime转ZonedDateTime  ZonedDateTime localDateTimeZonedDateTime = localDateTime.atZone(ZoneId.systemDefault()); //LocalDate转ZonedDateTime  ZonedDateTime localDateZonedDateTime = localDate.atStartOfDay(ZoneId.systemDefault());   转Date 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //Timestamp转Date  Date timestampDate = new Date(timestamp.getTime()); //Calendar转Date  Date calendarDate = calendar.getTime(); //Instant转Date  Date instantDate = Date.from(instant); //LocalDateTime转Date  Date localDateTimeDate = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); //ZonedDateTime转Date  Date zonedDateTimeDate = Date.from(zonedDateTime.toInstant()); //LocalDate转Date  Date localDateDate = Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());   转Timestamp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //Date转Timestamp  Timestamp dateTimestamp = new Timestamp(date.getTime()); //Calendar转Timestamp  Timestamp calendarTimestamp = new Timestamp(calendar.getTimeInMillis()); //Instant转Timestamp  Timestamp instantTimestamp = Timestamp.from(instant); //LocalDateTime转Timestamp  Timestamp localDateTimeTimestamp = Timestamp.valueOf(localDateTime); //ZonedDateTime转Timestamp  Timestamp zonedDateTimeTimestamp = Timestamp.from(zonedDateTime.toInstant()); //LocalDate转Timestamp  Timestamp localDateTimestamp = Timestamp.valueOf(localDate.atStartOfDay());   转Calendar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //Date转Calendar  Calendar dateCalendar = Calendar.getInstance(); dateCalendar.setTime(date); //Timestamp转Calendar  Calendar timestampCalendar = Calendar.getInstance(); timestampCalendar.setTimeInMillis(timestamp.getTime()); //Instant转Calendar  Calendar instantCalendar = GregorianCalendar.from(ZonedDateTime.ofInstant(instant, ZoneId.systemDefault())); //LocalDateTime转Calendar  Calendar localDateTimeCalendar = GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault())); //ZonedDateTime转Calendar  Calendar zonedDateTimeInstantCalendar = GregorianCalendar.from(zonedDateTime); //LocalDate转Calendar  Calendar localDateCalendar = GregorianCalendar.from(localDate.atStartOfDay(ZoneId.systemDefault()));   转LocalDate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //Date转LocalDate  LocalDate dateLocalDate = LocalDate.ofInstant(date.toInstant(), ZoneId.systemDefault()); //jdk11  LocalDate dateLocalDate = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()).toLocalDate(); //Timestamp转LocalDate  LocalDate timestampLocalDate = timestamp.toLocalDateTime().toLocalDate(); //Calendar转LocalDate  LocalDate calendarLocalDate = LocalDate.ofInstant(calendar.toInstant(), ZoneOffset.systemDefault()); //jdk11  LocalDate calendarLocalDate = LocalDateTime.ofInstant(calendar.toInstant(), ZoneOffset.systemDefault()).toLocalDate(); //Instant转LocalDate  LocalDate instantLocalDate = LocalDate.ofInstant(instant, ZoneId.systemDefault()); //jdk11  LocalDate instantLocalDate = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); //LocalDateTime转LocalDate  LocalDate localDateTimeLocalDate = localDateTime.toLocalDate(); //ZonedDateTime转LocalDate  LocalDate zonedDateTimeLocalDate = zonedDateTime.toLocalDate();   ","description":"","id":3,"section":"posts","tags":["Java","时间类"],"title":"Java中各种时间类型相互转换","uri":"http://RookieXv.github.io/posts/2020/04/java%E4%B8%AD%E5%90%84%E7%A7%8D%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"content":" 输入开始时间，截止时间，星期几，三个参数，获取这两个日期之间指定星期几的日期\n 一. 参数声明： 1 2 3  LocalDate start = LocalDate.of(2020, 4, 1); LocalDate end = LocalDate.of(2020, 5, 1); int week = 1;   二. 测试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * 获取指定时间内星期几的所有日期 * @Author liuwenxu.com (2020-04-26) * * @param start 开始日期 2020-04-01 * @param end 截止日期 2020-05-01 * @param week 星期几 1 * @return ArrayList\u0026lt;LocalDate\u0026gt; [2020-04-06, 2020-04-13, 2020-04-20, 2020-04-27] */ public static List getWeekInTimes(LocalDate start, LocalDate end, int week) { ArrayList\u0026lt;LocalDate\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); long days = ChronoUnit.DAYS.between(start, end); log.info(\u0026#34;[{}~{})之间共有：{}天\u0026#34;, start, end, days); Calendar startCalender = GregorianCalendar.from(start.atStartOfDay(ZoneId.systemDefault())); for (int i = 0; i \u0026lt; days - 1; i++) { startCalender.add(Calendar.DATE, 1); if (startCalender.get(Calendar.DAY_OF_WEEK) == week + 1) {// 1代表周日，7代表周六  list.add( LocalDateTime.ofInstant( startCalender.toInstant(), ZoneOffset.systemDefault() ).toLocalDate() ); } } log.info(\u0026#34;[{}~{})之间共有：{}个 星期{}\u0026#34;, start, end, list.size(), week); return list; }   三. 结果 1 2 3  - [2020-04-01~2020-05-01)之间共有：30天 - [2020-04-01~2020-05-01)之间共有：4个 星期1 [2020-04-06, 2020-04-13, 2020-04-20, 2020-04-27]   四. 拓展 获取当月所有周末的日期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * 获取当月的所有周末 * @Author liuwenxu.com (2020-04-26) * * @param year 2020 * @param month 4 * @return */ public static List getWeekendInMonth(int year, int month) { List list = new ArrayList(); Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.YEAR, year);// 不设置的话默认为当年  calendar.set(Calendar.MONTH, month - 1);// 设置月份  calendar.set(Calendar.DAY_OF_MONTH, 1);// 设置为当月第一天  int daySize = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);// 当月最大天数  for (int i = 0; i \u0026lt; daySize - 1; i++) { calendar.add(Calendar.DATE, 1);//在第一天的基础上加1  int week = calendar.get(Calendar.DAY_OF_WEEK); if (week == Calendar.SATURDAY || week == Calendar.SUNDAY) {// 1代表周日，7代表周六 判断这是一个星期的第几天从而判断是否是周末  list.add(year + \u0026#34;-\u0026#34; + month + \u0026#34;-\u0026#34; + calendar.get(Calendar.DAY_OF_MONTH));// 得到当天是一个月的第几天  } } return list; }   结果： 1  [2020-4-4, 2020-4-5, 2020-4-11, 2020-4-12, 2020-4-18, 2020-4-19, 2020-4-25, 2020-4-26]   五. 附：代码原文件 ","description":"","id":4,"section":"posts","tags":["Java","时间类"],"title":"获取指定时间内指定星期几的所有日期","uri":"http://RookieXv.github.io/posts/2020/04/%E6%97%B6%E9%97%B4%E6%AE%B5%E5%91%A8%E5%87%A0%E7%9A%84%E6%97%A5%E6%9C%9F/"},{"content":"一、Nacos简介 官网介绍：Nacos 致力于帮助您发现、配置和管理微服务。\nhttps://nacos.io/zh-cn/index.html\nNacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。\n二、安装和启动 1、安装 1）官网下载压缩包 https://github.com/alibaba/nacos/releases\n2）Github下载 1 2 3 4 5 6 7  git clone https://github.com/alibaba/nacos.git cd nacos/ mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U ls -al distribution/target/ // change the $version to your actual path cd distribution/target/nacos-server-$version/nacos/bin   2、启动 Linux/Unix/Mac 启动命令(standalone代表着单机模式运行，非集群模式):\n1  sh startup.sh -m standalone   如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：\n1  bash startup.sh -m standalone   Windows 启动命令：\n1  cmd startup.cmd   或者双击startup.cmd运行文件。\n","description":"","id":5,"section":"posts","tags":["Nacos","Spring Cloud"],"title":"《Nacos系列》之安装与启动","uri":"http://RookieXv.github.io/posts/2020/04/1.nacos/"},{"content":"Nacos持久化 Nacos使用的是内嵌数据库 Derby (Apache Derby)，目前Nacos仅支持Mysql数据库，且版本要求：5.6.5+\n1、准备环境 Windows 10\nMySQL 5.7.x\n2、准备数据库 1）新建数据库 新建数据库nacos，导入Nacos安装目录下的conf/nacos-mysql.sql的sql文件。\n可以看到数据库增加了11张表：\n2）修改配置文件 打开conf/application.properties，修改数据库配置：\nspring.datasource.platform=mysql\rdb.num=1\rdb.url.0=jdbc:mysql://127.0.0.1:3306/mynacos?characterEncoding=utf8\u0026amp;connectTimeout=1000\u0026amp;socketTimeout=3000\u0026amp;autoReconnect=true\rdb.user=root\rdb.password=123456\r3、备份原配置 登录Nacos，导出原来的配置文件。\n修改数据库配置之后，原配置自然就不在了，所以提前做好备份，后面可以直接导入。\n每个命名空间都要单独导出：\n4、重启Nacos 重新启动Nacos，登录后发现配置全没了。\n按照原来的命名空间，重新创建。\n然后，在对应的命名空间下导入原配置文件即可：\n5、修改项目下的配置信息 修改项目namespace配置，启动测试，正常读取！\n","description":"","id":6,"section":"posts","tags":["Nacos","Spring Cloud"],"title":"《Nacos系列》之持久化","uri":"http://RookieXv.github.io/posts/2020/04/5.nacos-mysql/"},{"content":"Nacos注册中心 服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。\n1、CAP理论 CAP理论是分布式架构中的重要理论。\n C：一致性(Consistency) (所有节点在同一时间具有相同的数据) A：可用性(Availability) (保证每个请求不管成功或者失败都有响应) P：分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)  2、主流注册中心对比     Nacos Eureka Consul CoreDNS Zookeeper     一致性协议 CP+AP AP CP — CP   健康检查 TCP/HTTP/MYSQL/Client Beat Client Beat TCP/HTTP/gRPC/Cmd — Keep Alive   负载均衡策略 权重/metadata/Selector Ribbon Fabio RoundRobin —   雪崩保护 有 有 无 无 无   自动注销实例 支持 支持 不支持 不支持 支持   访问协议 HTTP/DNS HTTP HTTP/DNS DNS TCP   监听支持 支持 支持 支持 不支持 支持   多数据中心 支持 支持 支持 不支持 不支持   跨注册中心同步 支持 不支持 支持 不支持 不支持   SpringCloud集成 支持 支持 支持 不支持 不支持   Dubbo集成 支持 不支持 不支持 不支持 支持   K8S集成 支持 不支持 支持 支持 不支持    Nacos除了服务的注册发现之外，还支持动态配置服务。\n一句话概括就是Nacos = Spring Cloud注册中心 + Spring Cloud配置中心。\n3、集成到SpringCloud中 创建好SC父工程，添加子模块\n1）添加pom 1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   2）主启动类添加注解 1  @EnableDiscoveryClient   3）添加application.yml配置文件 1 2 3 4 5 6 7 8 9 10 11 12  spring:application:name:usercloud:nacos:discovery:server-addr:127.0.0.1:8848management:endpoints:web:exposure:include:\u0026#39;*\u0026#39;  如果不想使用 Nacos 作为您的服务注册与发现，可以将spring.cloud.nacos.discovery 设置为 false\n4）启动项目 以nacos/nacos，登录到127.0.0.1:8848/nacos，可以看到user服务已经注册成功：\n5）服务的 EndPoint spring-cloud-starter-alibaba-nacos-discovery 在实现的时候提供了一个EndPoint,EndPoint的访问地址为 http://ip:port/actuator/nacos-discovery。 EndPoint 的信息主要提供了两类:\n1、subscribe: 显示了当前有哪些服务订阅者\n2、NacosDiscoveryProperties: 显示了当前服务实例关于 Nacos 的基础配置\n至此，Spring Cloud使用Nacos作为注册中心已经初步完成，其他配置根据自身业务修改即可。\n","description":"","id":7,"section":"posts","tags":["Nacos","Spring Cloud","注册中心"],"title":"《Nacos系列》之注册中心","uri":"http://RookieXv.github.io/posts/2020/04/2.nacos-discovery/"},{"content":" 今天正在吃饭，一个朋友提出了一个他面试中遇到的问题，MySQL允许在唯一索引字段中添加多个NULL值。\n这个问题对于我一个非专业DBA来说，也没特地去验证过，所以正好借此机会验证一下，做个记录：\n 测试环境：\n1 2 3  数据库：MySQL5.7.25 数据库引擎：InnoDB 连接工具：Navicat Premium   首先，创建数据库，并创建测试表 test：\n1 2 3 4 5 6  DROP TABLE IF EXISTS `test`; CREATE TABLE `test` ( `id` int(11) NOT NULL COMMENT \u0026#39;ID\u0026#39;, `name` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL COMMENT \u0026#39;姓名\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Dynamic;   然后，我们给name字段添加一个唯一索引：\n1  ALTER TABLE `test` ADD UNIQUE ( `name`);   最后，我们尝试插入两条name字段为null的数据：\n1 2  INSERT INTO `test` VALUES (1, NULL); INSERT INTO `test` VALUES (2, NULL);   并没有报错，说明MySQL允许在唯一索引字段中添加多个NULL值。\n数据表如下：\nMySQL的官方文档给出的解释为：\n A UNIQUE index creates a constraint such that all values in the index must be distinct. An error occurs if you try to add a new row with a key value that matches an existing row. This constraint does not apply to NULL values except for the BDB storage engine. For other engines, a UNIQUE index allows multiple NULL values for columns that can contain NULL.\n 我们可以看出，此约束不适用于除BDB存储引擎之外的空值。对于其他引擎，唯一索引允许包含空值的列有多个空值。\n网友给出的解释为：\n 在sql server中，唯一索引字段不能出现多个null值\n在mysql 的innodb引擎中，是允许在唯一索引的字段中出现多个null值的。\n根据NULL的定义，**NULL表示的是未知，因此两个NULL比较的结果既不相等，也不不等，结果仍然是未知。**根据这个定义，多个NULL值的存在应该不违反唯一约束，所以是合理的，在oracel也是如此。\n 这个解释很形象，既不相等，也不不等，所以结果未知。\n至于，sqlserver和MySQL其他引擎还有待验证。\n","description":"","id":8,"section":"posts","tags":["MySQL","UNIQUE"],"title":"MySQL允许在唯一索引字段中添加多个NULL值","uri":"http://RookieXv.github.io/posts/2020/03/mysql%E5%85%81%E8%AE%B8%E5%9C%A8%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AAnull%E5%80%BC/"},{"content":" 在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。\n 关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。\nCOUNT MySQL官网给出的解释是：\n1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。\n2、如果查询结果没有命中任何记录，则返回0\n3、但是，值得注意的是，COUNT(*) 的统计结果中，会包含值为NULL的行数。\n例如：\n1 2 3 4 5 6 7 8  create table #bla(id int,age int) insert #student values(null,null) insert #student values(1,null) insert #student values(null,1) insert #student values(1,null) insert #student values(null,1) insert #student values(1,null) insert #student values(null,null)   使用语句count(*),count(id),count(id2)查询结果如下：\n1 2 3  select count(*),count(id),count(age) from #student results 7 3 2   COUNT(常量) 和 COUNT(\\*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。\n而COUNT(*)是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。\n SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。\n COUNT(*)的优化 区分不同的执行引擎，MySQL中比较常用的执行引擎就是InnoDB和MyISAM。\nMyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的COUNT(*)有关，那就是MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。\nMyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。\nInnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。\n所以，相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。\n至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。\nCOUNT(1)  InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.\n 所以，对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！\n建议使用COUNT(*)！因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。\nCOUNT(字段) 最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。\n相比COUNT(*)，COUNT(字段)多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。\n总结 本文介绍了COUNT函数的用法，主要用于统计表行数。主要用法有COUNT(*)、COUNT(字段)和COUNT(1)。\n因为COUNT()是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT()查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。\n在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。\n因为COUNT()是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用COUNT()查询表的行数！\n","description":"数据库COUNT(*)、COUNT(字段)和COUNT(1)的异同","id":9,"section":"posts","tags":["MySQL","COUNT"],"title":"数据库COUNT(*)、COUNT(字段)和COUNT(1)的异同","uri":"http://RookieXv.github.io/posts/2020/03/count/"},{"content":"在resources目录下，新建banner.txt，将下面内容拷贝进去，重新启动即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ${AnsiColor.BRIGHT_YELLOW} _ooAoo_ o9999999o 88\u0026#34; . \u0026#34;88 (| -_- |) O\\ = /O ____/`---\u0026#39;\\____ .\u0026#39; \\\\| |// `.  / \\\\||| : |||// \\  / _||||| -:- |||||- \\ | | \\\\\\ - /// | |  | \\_| \u0026#39;\u0026#39;\\---/\u0026#39;\u0026#39; | | \\ .-\\__ `-` ___/-. / ___`. .\u0026#39; /--.--\\ `. . __ .\u0026#34;\u0026#34; \u0026#39;\u0026lt; `.___\\_\u0026lt;|\u0026gt;_/___.\u0026#39; \u0026gt;\u0026#39;\u0026#34;\u0026#34;. | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-\u0026#39;====== `=---=\u0026#39; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG ${AnsiColor.BRIGHT_CYAN} Application Version: ${application.version}${application.formatted-version} Spring Boot Version: ${spring-boot.version}${spring-boot.formatted-version}   ","description":"","id":10,"section":"posts","tags":["MySQL","UNIQUE"],"title":"MySQL允许在唯一索引字段中添加多个NULL值","uri":"http://RookieXv.github.io/posts/2019/12/springboot%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88/"},{"content":"我们在写博客时，经常看到大佬们会把项目的结构以下面的形式画出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ├─src │ ├─main │ │ ├─java │ │ │ └─com │ │ │ └─example │ │ │ └─mybatisplus │ │ │ ├─config │ │ │ ├─controller │ │ │ ├─entity │ │ │ ├─mapper │ │ │ └─service │ │ │ └─impl │ │ └─resources │ │ ├─mapper │ │ │ └─mybatisplus │ │ ├─static │ │ └─templates │ └─test │ └─java └─target   那么我们该怎么像大佬一样优秀呢？其实很简单，我们可以使用windows自带的 tree 命令。\n其实tree命令 是一个很不错的功能。可以把指定文件夹的所以文件用树状罗列出来。然后我们查看树状结构就能够了解有那些文件，然后我们在去查看需要关心的有那些文件就可以了。\n用法：TREE [d:][path1] [/A][/F] \u0026gt; [d:][path2/pro_tree.txt]\n​ ↓ ↓ ↓ ↓ ↓\n解读：命令 项目路径 符号 文件 生成的tree保存到文件\n我们按 win+R 键,输入cmd，进入黑窗口，选择进入我们要生成目录树的目录下，输入\n1  tree /F   即可生成具体的文件的目录树，如果只想具体的文件夹，则直接输入tree。\n","description":"","id":11,"section":"posts","tags":["shell"],"title":"生成项目目录树","uri":"http://RookieXv.github.io/posts/2019/12/tree/"},{"content":" 操千曲而后晓声，观千剑而后识器。\n　《文心雕龙》—— 刘勰\n 欢迎来到我的小站，很高兴遇见你！🤝\n##🏠 关于本站\n这个话题，我苦思良久，要从一只 🦇 的故事说起。\n己亥末，庚子春。\n荆楚大疫，染者数万计，众惶恐。\n举国防，足不出，街无舟车，万巷空寂。\n然，吾观blog不美，遂搭之。\n许久之前，我的个人博客用的是 hexo + github pages 搭建的，换电脑之后，原文件丢失，就没有再维护，打开一看，很是不好看。\n本网站主题，采用hugo。\n本站「Java那些事儿」是一个以编程技术分享为主，IT领域其他的资讯推送为辅的技术娱乐型个人博客，主要关注Java，springboot，springcloud，热点资讯以及各种小工具黑科技等。\n同步微信公众号：「Java那些事儿」，均为个人运营，公众号会优先推送。\n","description":"About Page","id":12,"section":"","tags":null,"title":"关于我","uri":"http://RookieXv.github.io/about/"},{"content":" mybatis-plus愿景：\n我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。\n 前言： mybatis 在持久层框架中还是比较火的，使用也很方便。虽然mybatis可以直接在xml中通过SQL语句操作数据库，很是灵活。但正其操作都要通过SQL语句进行，就必须写大量的xml文件，很是麻烦。\n**mybatis-plus **就很好的解决了这个问题。\n一、mybatis-plus简介： Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。这是官方给的定义，关于mybatis-plus的更多介绍及特性，可以参考mybatis-plus官网。那么它是如何增强的呢？其实就是它已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，就类似于JPA。\n二、特性  无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作  三、框架结构 官网：https://mybatis.plus\n接下来我们来看看在项目中具体怎么使用：\n（二）mybatis-plus的安装配置\n","description":"","id":13,"section":"posts","tags":["Mybatis Plus"],"title":"（一）初识Mybatis-Plus","uri":"http://RookieXv.github.io/posts/2019/05/%E4%B8%80%E5%88%9D%E8%AF%86mybatis-plus/"},{"content":" 上一篇我们已经把所有需要的东西配置好了，接下来我们准备连接数据库生成代码。\n 首先准备一张student表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for student -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT \u0026#39;学生id\u0026#39;, `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \u0026#39;姓名\u0026#39;, `age` int(11) NULL DEFAULT NULL COMMENT \u0026#39;年龄\u0026#39;, `is_valid` int(11) NULL DEFAULT NULL COMMENT \u0026#39;是否在读\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; SET FOREIGN_KEY_CHECKS = 1;   一、配置代码生成器  Mybatis-Plus的代码生成器是不需要依赖spring的，所以我们可以直接在test中新建一个类CodeGeneratorDefault\n 默认模板生成： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class CodeGeneratorDefault { /** * \u0026lt;p\u0026gt; * 读取控制台内容 * \u0026lt;/p\u0026gt; */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\u0026#34;请输入\u0026#34; + tip + \u0026#34;：\u0026#34;); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\u0026#34;请输入正确的\u0026#34; + tip + \u0026#34;！\u0026#34;); } public static void main(String[] args) { // 代码生成器  AutoGenerator mpg = new AutoGenerator(); // 全局配置  GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\u0026#34;user.dir\u0026#34;); gc.setOutputDir(projectPath + \u0026#34;/src/main/java\u0026#34;); gc.setAuthor(\u0026#34;liuwenxu\u0026#34;); gc.setOpen(false); gc.setSwagger2(true); // 实体属性 Swagger2 注解  mpg.setGlobalConfig(gc); // 数据源配置  DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\u0026#34;jdbc:mysql://172.30.7.143:3306/wxyj_sj?serverTimezone=UTC\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026#34;); // dsc.setSchemaName(\u0026#34;public\u0026#34;);  dsc.setDriverName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dsc.setUsername(\u0026#34;wxyj\u0026#34;); dsc.setPassword(\u0026#34;123456\u0026#34;); mpg.setDataSource(dsc); // 包配置  PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\u0026#34;模块名\u0026#34;)); pc.setParent(\u0026#34;com.example\u0026#34;); mpg.setPackageInfo(pc); // 自定义配置  InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing  } }; List\u0026lt;FileOutConfig\u0026gt; focList = new ArrayList\u0026lt;\u0026gt;(); focList.add(new FileOutConfig(\u0026#34;/templates/mapper.xml.ftl\u0026#34;) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输入文件名称  return projectPath + \u0026#34;/src/main/resources/mapper/\u0026#34; + pc.getModuleName() + \u0026#34;/\u0026#34; + tableInfo.getEntityName() + \u0026#34;Mapper\u0026#34; + StringPool.DOT_XML; } }); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); mpg.setTemplate(new TemplateConfig().setXml(null)); // 策略配置  StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(\u0026#34;com.baomidou.ant.common.BaseEntity\u0026#34;);  strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); //strategy.setSuperControllerClass(\u0026#34;com.baomidou.ant.common.BaseController\u0026#34;);  strategy.setInclude(scanner(\u0026#34;表名\u0026#34;)); //strategy.setSuperEntityColumns(\u0026#34;id\u0026#34;);  strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(\u0026#34;_\u0026#34;); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); } }   点击运行，在输入栏按照以下流程执行即可\n执行后项目结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  ├─src │ ├─main │ │ ├─java │ │ │ └─com │ │ │ └─example │ │ │ └─mybatisplus │ │ │ │ MybatisPlusApplication.java │ │ │ │ │ │ │ ├─config │ │ │ │ SwaggerConfig.java │ │ │ │ │ │ │ ├─controller │ │ │ │ StudentController.java │ │ │ │ │ │ │ ├─entity │ │ │ │ Student.java │ │ │ │ │ │ │ ├─mapper │ │ │ │ StudentMapper.java │ │ │ │ │ │ │ └─service │ │ │ │ IStudentService.java │ │ │ │ │ │ │ └─impl │ │ │ StudentServiceImpl.java │ │ │ │ │ └─resources │ │ │ application.yml │ │ │ │ │ ├─mapper │ │ │ └─mybatisplus │ │ │ StudentMapper.xml │ │ │ │ │ ├─static │ │ └─templates │ │ controller-mine.java.ftl │ │ entity-mine.java.ftl │ │ mapper-mine.java.ftl │ │ service-mine.java.ftl │ │ serviceImpl-mine.java.ftl │ │ │ └─test │ └─java │ CodeGenerator.java │ CodeGeneratorDefault.java   自定义模板生成：  有些小伙伴不满足于默认模板生成的文件，下面我们来演示自定义模板：\n 1、添加freemarker依赖：\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   2、编写自定义模板：（文末有源码链接）\ncontroller-mine.java.ftl\rentity-mine.java.ftl\rmapper-mine.java.ftl\rservice-mine.java.ftl\rserviceImpl-mine.java.ftl\r3、修改代码生成器配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class CodeGenerator { /** * \u0026lt;p\u0026gt; * 读取控制台内容 * \u0026lt;/p\u0026gt; */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\u0026#34;请输入\u0026#34; + tip + \u0026#34;：\u0026#34;); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\u0026#34;请输入正确的\u0026#34; + tip + \u0026#34;！\u0026#34;); } public static void main(String[] args) { // 代码生成器  AutoGenerator mpg = new AutoGenerator(); // 全局配置  GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\u0026#34;user.dir\u0026#34;); gc.setOutputDir(projectPath + \u0026#34;/src/main/java\u0026#34;); gc.setAuthor(\u0026#34;liuwenxu\u0026#34;); gc.setOpen(false); gc.setSwagger2(true); // 实体属性 Swagger2 注解  mpg.setGlobalConfig(gc); // 数据源配置  DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\u0026#34;jdbc:mysql://172.30.7.143:3306/wxyj_sj?serverTimezone=UTC\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026#34;); // dsc.setSchemaName(\u0026#34;public\u0026#34;);  dsc.setDriverName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dsc.setUsername(\u0026#34;wxyj\u0026#34;); dsc.setPassword(\u0026#34;123456\u0026#34;); mpg.setDataSource(dsc); // 包配置  PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\u0026#34;模块名\u0026#34;)); pc.setParent(\u0026#34;com.example\u0026#34;); mpg.setPackageInfo(pc); // 自定义配置  InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing  } }; List\u0026lt;FileOutConfig\u0026gt; focList = new ArrayList\u0026lt;\u0026gt;(); focList.add(new FileOutConfig(\u0026#34;/templates/mapper.xml.ftl\u0026#34;) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输入文件名称  return projectPath + \u0026#34;/src/main/resources/mapper/\u0026#34; + pc.getModuleName() + \u0026#34;/\u0026#34; + tableInfo.getEntityName() + \u0026#34;Mapper\u0026#34; + StringPool.DOT_XML; } }); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板  TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板  //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别  templateConfig.setEntity(\u0026#34;templates/entity-mine.java\u0026#34;); templateConfig.setMapper(\u0026#34;templates/mapper-mine.java\u0026#34;); templateConfig.setService(\u0026#34;templates/service-mine.java\u0026#34;); templateConfig.setServiceImpl(\u0026#34;templates/serviceImpl-mine.java\u0026#34;); templateConfig.setController(\u0026#34;templates/controller-mine.java\u0026#34;); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置  StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(\u0026#34;com.baomidou.ant.common.BaseEntity\u0026#34;);  strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); //strategy.setSuperControllerClass(\u0026#34;com.baomidou.ant.common.BaseController\u0026#34;);  strategy.setInclude(scanner(\u0026#34;表名\u0026#34;)); //strategy.setSuperEntityColumns(\u0026#34;id\u0026#34;);  strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(\u0026#34;_\u0026#34;); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); } }   附：项目源码 ","description":"","id":14,"section":"posts","tags":["Mybatis Plus"],"title":"（三）Mybatis-Plus代码生成器","uri":"http://RookieXv.github.io/posts/2019/05/%E4%B8%89mybatis-plus%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"content":" 上一篇文章我们认识了Mybatis-Plus，这篇文章我们一起学习Mybatis-Plus在项目中怎么使用。\n 项目结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  src ├─main │ ├─java │ │ └─com │ │ └─example │ │ └─mybatisplus │ │ └─config │ └─resources │ ├─static │ └─templates └─test └─java └─com └─example └─mybatisplus   一、安装 全新的 MyBatis-Plus 3.0 版本基于 JDK8，提供了 lambda 形式的调用，所以安装集成 MP3.0 要求如下：\n JDK 8+ Maven  JDK7 以及下的请参考 MP2.0 版本官方文档，地址：2.0 文档\n我们在该项目中集成了mybatis-plus，lombok，swagger，集体配置如下：\n# Spring Boot Maven：\n1 2 3 4 5 6 7  \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.0.5.RELEASE\u0026lt;/spring-boot.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.0-RELEASE\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;swagger.version\u0026gt;2.9.2\u0026lt;/swagger.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.16.10\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;!-- 连接mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-plus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- swagger配置 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   # Spring MVC Maven:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;!-- mybatis-plus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 连接mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- swagger配置 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   引入 MyBatis-Plus 之后请不要再次引入 MyBatis 以及 MyBatis-Spring，以避免因版本差异导致的问题。\n二、配置 MyBatis-Plus 的配置异常的简单，我们仅需要一些简单的配置即可使用 MyBatis-Plus 的强大功能。\n# Spring Boot 配置 MapperScan 注解 1 2 3 4 5 6 7 8 9  @SpringBootApplication @MapperScan(\u0026#34;com.example.mybatis-plus.**.mapper\u0026#34;) public class MybatisPlusApplication { public static void main(String[] args) { SpringApplication.run(MybatisPlusApplication.class, args); } }   配置application.yml 1 2 3 4 5 6 7 8 9 10  mybatis-plus: # xml地址 mapper-locations: classpath*:mapper/*/*Mapper.xml # 实体扫描，多个package用逗号或者分号分隔 #自己的实体类地址 type-aliases-package: com.example.mybatis-plus configuration: # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启驼峰命名法 map-underscore-to-camel-case: true   # Spring MVC   配置 MapperScan   1 2 3  \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.baomidou.mybatisplus.samples.quickstart.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;     调整 SqlSessionFactory 为 MyBatis-Plus 的 SqlSessionFactory   1 2 3  \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   通常来说，一般的简单工程，通过以上配置即可正常使用 MyBatis-Plus。\n# swagger配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  package com.example.mybatisplus.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * Copyright (C), 2016-2019, Mobius-Vision * FileName: SwaggerConfig * Author: liuwenxu * Date: 2019/7/10 14:59 * Description: 接口文档说明 http://localhost:8089/swagger-ui.html#/ */ @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.example.mybatis-plus.controller\u0026#34;)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\u0026#34;mybatis-plus\u0026#34;) .description(\u0026#34;mybatis-plus\u0026#34;) .contact(new Contact(\u0026#34;liuwenxu\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;)) .version(\u0026#34;2.0\u0026#34;) .build(); } }   ","description":"","id":15,"section":"posts","tags":["Mybatis Plus"],"title":"（二）Mybatis-Plus的安装配置","uri":"http://RookieXv.github.io/posts/2019/05/%E4%BA%8Cmybatis-plus%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  import java.io.File; import java.io.IOException; import java.net.URL; public class MyUrlDemo { public static void main(String[] args) { MyUrlDemo muDemo = new MyUrlDemo(); try { muDemo.showURL(); } catch (IOException e) { // TODO Auto-generated catch block  e.printStackTrace(); } } public void showURL() throws IOException { // 第一种：获取类加载的根路径 D:\\git\\daotie\\daotie\\target\\classes  File f = new File(this.getClass().getResource(\u0026#34;/\u0026#34;).getPath()); System.out.println(f); // 获取当前类的所在工程路径; 如果不加“/” 获取当前类的加载目录 D:\\git\\daotie\\daotie\\target\\classes\\my  File f2 = new File(this.getClass().getResource(\u0026#34;\u0026#34;).getPath()); System.out.println(f2); // 第二种：获取项目路径 D:\\git\\daotie\\daotie  File directory = new File(\u0026#34;\u0026#34;);// 参数为空  String courseFile = directory.getCanonicalPath(); System.out.println(courseFile); // 第三种： file:/D:/git/daotie/daotie/target/classes/  URL xmlpath = this.getClass().getClassLoader().getResource(\u0026#34;\u0026#34;); System.out.println(xmlpath); // 第四种： D:\\git\\daotie\\daotie  System.out.println(System.getProperty(\u0026#34;user.dir\u0026#34;)); /* * 结果： C:\\Documents and Settings\\Administrator\\workspace\\projectName * 获取当前工程路径 */ // 第五种： 获取所有的类路径 包括jar包的路径  System.out.println(System.getProperty(\u0026#34;java.class.path\u0026#34;)); } }   ","description":"","id":16,"section":"posts","tags":["路径"],"title":"java中获取类加载路径和项目根路径的5种方法","uri":"http://RookieXv.github.io/posts/2019/05/java%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%A0%B9%E8%B7%AF%E5%BE%84%E7%9A%845%E7%A7%8D%E6%96%B9%E6%B3%95/"}]